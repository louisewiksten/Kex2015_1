package yahtzee;

import java.util.Arrays;

/**
 * Trying to solve yahtzee by saving states.
 * 
 * Each state is defined by a set of dice values, arranged in order of size.
 * Each state has a set of edges containing the probability of getting to the
 * next state.
 * 
 * @author D Jendeberg and L Wiksten
 *
 */
public class OptimalStatebasedAlgorithm {
	public ScoreCard sc;
	public Tuple[] V1;
	public static final int V1LENGTH = (int) (Math.pow(2, 15) * 64);
	public Element[] V2;
	public static final int V2LENGTH = V1LENGTH * 252;
	public Element[] V3;
	public static final int V3LENGTH = V1LENGTH * 462;

	/**
	 * Objects for V1.
	 * 
	 * @author D Jendeberg and L Wiksten
	 *
	 */
	static class Tuple {
		public boolean[] playableCategories;
		public int upper;

		public Tuple(boolean[] categories, int upper) {
			this.playableCategories = categories;
			this.upper = upper;
		}

		public boolean equals(Tuple a) {
			if (Arrays.equals(this.playableCategories, a.playableCategories))
				if (this.upper == a.upper)
					return true;
			return false;
		}
	}

	/**
	 * Objects for V2, V4, V6
	 * 
	 * @author D Jendeberg L Wiksten
	 *
	 */
	static class Element {
		public Tuple u;
		public short[] dices;

		public Element(Tuple u, short[] dices) {
			this.u = u;
			this.dices = new short[dices.length];
			this.dices = dices.clone();
		}
	}

	/**
	 * Constructor for the graph.
	 */
	public OptimalStatebasedAlgorithm() {
		System.out
				.println("Memory needed is: "
						+ ((((long) V1LENGTH * 16) + ((long) V2LENGTH * 58) + ((long) V3LENGTH * 58)) / 8));
		V1 = new Tuple[V1LENGTH];
		V2 = new Element[V2LENGTH];
		V3 = new Element[V3LENGTH];

		int iter = 0; // This is the position in the vertices list.
		final int n = 15;
		System.out.println("Starting with V1.");
		for (int upper = 0; upper < 64; upper++) {
			// Create all combinations of a boolean array.
			for (int i = 0; i < Math.pow(2, n); i++) {
				String bin = Integer.toBinaryString(i);
				while (bin.length() < n)
					bin = "0" + bin;
				char[] chars = bin.toCharArray();
				boolean[] boolArray = new boolean[n];
				for (int j = 0; j < chars.length; j++) {
					boolArray[j] = chars[j] == '0' ? true : false;
				}
				Tuple u = new Tuple(boolArray, upper);
				V1[iter] = u;
				iter++;
			}
		}
		System.out.println("Number of laps: " + iter
				+ " compared to expected: " + V1LENGTH);
		System.out.println("Now doing V2.");
		// V2, V4, V6 looks alike with different strings.

		iter = 0; // This is the position in the vertices list.
		for (int i = 0; i < V1LENGTH; i++) { // i = element in V1
			Tuple u = V1[i];
			for (short k = 1; k < 7; k++) {
				for (short l = 1; l < 7; l++) {
					for (short m = 0; m < 7; m++) {
						for (short o = 0; o < 7; o++) {
							for (short p = 0; p < 7; p++) {
								V2[iter] = new Element(u, new short[] { k, l,
										m, o, p });
								iter++;
							}
						}
					}
				}
			}
			if(i == (i/1000)*1000)
				System.out.println("Currently done with " + i);
		}
		System.out.println("Number of laps: " + iter
				+ " compared to expected: " + V2LENGTH);
		System.out.println("Now doing V3.");
		// V3 and V5 looks alike with different strings.
		iter = 0; // This is the position in the vertices list.
		for (int i = 0; i < V1LENGTH; i++) {
			Tuple u = V1[i];
			for (short k = 1; k < 7; k++) {
				V3[iter] = new Element(u, new short[] { k });
				iter++;
				for (short l = 1; l < 7; l++) {
					V3[iter] = new Element(u, new short[] { k, l });
					iter++;
					for (short m = 0; m < 7; m++) {
						V3[iter] = new Element(u, new short[] { k, l, m });
						iter++;
						for (short o = 0; o < 7; o++) {
							V3[iter] = new Element(u,
									new short[] { k, l, m, o });
							iter++;
							for (short p = 0; p < 7; p++) {
								V3[iter] = new Element(u, new short[] { k, l,
										m, o, p });
								iter++;
							}
						}
					}
				}
			}
			iter++;
		}
		System.out.println("Number of laps: " + iter
				+ " compared to expected: " + V3LENGTH);
	}

	/**
	 * @param u
	 *            Element from V1.
	 * @param v
	 *            Element from V6.
	 * @return Score returned by following that path.
	 */
	public int score(Tuple u, Element v) {
		int score = 0;
		for (int i = 0; i < 16; i++)
			if (u.playableCategories[i]) {
				int tmpScore = pointsEarned(v.dices, i, u.upper);
				if (tmpScore > score)
					score = tmpScore;
			}
		return score;
	}

	/**
	 * Calculates the points generated by the scoreing from the wraparound from
	 * V6 to V1, also known as scoring the points.
	 * 
	 * @param v
	 *            An element from V6.
	 * @param u
	 *            A tuple from V1.
	 * @return The score generated.
	 */
	public int S(Element v, Tuple u) {
		int score = 0;
		for (int i = 1; i < 16; i++) {
			if (v.u.playableCategories[i] != u.playableCategories[i])
				// Finds the scored position.
				score = pointsEarned(v.dices, i, v.u.upper);
		}
		return score;
	}

	/**
	 * Calculates score from wraparound without bonus.
	 * 
	 * @param v
	 *            An element from V6.
	 * @param u
	 *            A tuple from V1.
	 * @return The score generated without bonus.
	 */
	public int SPrime(Element v, Tuple u) {
		int score = 0;
		for (int i = 1; i < 16; i++) {
			if (v.u.playableCategories[i] != u.playableCategories[i]) {
				// Finds the scored position.
				score = pointsEarned(v.dices, i, v.u.upper);
				if (score > 50) { // Must be upper and contain bonus
					score -= 50;
				}
			}
		}
		return score;
	}

	/**
	 * Calculates the score generated by a certain set of dices in a given
	 * category.
	 * 
	 * @param dices
	 *            Dice values.
	 * @param category
	 *            Category (1-15).
	 * @param upper
	 *            Sum of top category scores.
	 * @return The score generated by the parameters.
	 */
	public int pointsEarned(short[] dices, int category, int upper) {
		int score = 0;
		Arrays.sort(dices);

		switch (category) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			for (int i = 0; i < 5; i++)
				if (dices[i] == category)
					score += category;
			if ((upper + category) > 62 && !(upper > 63))
				score += 50;
			break;
		case 7: // pair
			for (int i = 0; i < 4; i++)
				if (dices[i] == dices[i + 1])
					score = 2 * dices[i];
			break;
		case 8: // twopair
			for (int i = 0; i < 2; i++)
				if (dices[i] == dices[i + 1])
					for (int j = 2 + i; j < 4; j++)
						if (dices[j] == dices[j + 1])
							score = 2 * dices[i] + 2 * dices[j];
			break;
		case 9: // Three of a kind
			for (int i = 0; i < 3; i++)
				if (dices[i] == dices[i + 2])
					score = 3 * dices[i];
			break;
		case 10: // Four of a kind
			for (int i = 0; i < 2; i++)
				if (dices[i] == dices[i + 3])
					score = 4 * dices[i];
			break;
		case 11:// Small straight
			if (dices[0] == 1 && dices[1] == 2 && dices[2] == 3
					&& dices[3] == 4 && dices[4] == 5)
				score = 15;
			break;
		case 12: // Large straight
			if (dices[0] == 2 && dices[1] == 3 && dices[2] == 4
					&& dices[3] == 5 && dices[4] == 6)
				score = 20;
			break;
		case 13: // Full House
			if (dices[0] == dices[2] && dices[3] == dices[4]
					&& dices[0] != dices[4])
				score = 3 * dices[0] + 2 * dices[4];
			else if (dices[0] == dices[1] && dices[2] == dices[4]
					&& dices[0] != dices[4])
				score = 2 * dices[0] + 3 * dices[4];
			break;
		case 14: // Chance
			for (int dice : dices) {
				score += dice;
			}
			break;
		case 15: // Yahtzee
			if (dices[0] == dices[4]) {
				score = 50;
			}
		}
		return score;
	}

	/**
	 * Method described in literature
	 * 
	 * @param u
	 *            A terminal value of V1, this means a tuple where the entire
	 *            category list is scored. If not terminal, calculate future
	 *            score.
	 * @return The total score of a path leading to this state.
	 */
	public double X(Tuple u) {
		int sum = 0;
		boolean terminal = true;
		for (boolean playableCategory : u.playableCategories)
			if (playableCategory) {
				terminal = false;
				break;
			}
		if (terminal) {
			return 0;
		} else {
			// Not a terminal tuple.
			for (int i = 0; i < V2.length; i++) {
				if (V2[i].u.equals(u)) {
					// We found a matching state
					sum += X(V2[i], 2);
				}
			}
			return sum;
		}
	}

	/**
	 * 
	 * @param v
	 *            An element from V2-V6, never Terminal
	 * @return A double representing the expected score from here.
	 */
	public double X(Element v, int state) {
		if (state == 3 || state == 5) {
			double sum = 0;
			if (state == 3) {
				for (int i = 0; i < V2.length; i++) {
					if (V2[i].u.equals(v.u) && V2[i].u.upper == v.u.upper
							&& contains(V2[i].dices, v.dices)) {
						sum += probability(v, V2[i]) * X(V2[i], state + 1);
					}
				}
			} else { // if (v.vertices == "V5")
				for (int i = 0; i < V2.length; i++) {
					if (V2[i].u.equals(v.u) && V2[i].u.upper == v.u.upper
							&& contains(V2[i].dices, v.dices)) {
						sum += probability(v, V2[i]) * X(V2[i], state + 1);
					}
				}
			}
			return sum;
		} else if (state == 2 || state == 4) {
			double max = 0;
			if (state == 2) {
				for (int i = 0; i < V3.length; i++) {
					if (V3[i].u.equals(v.u) && V3[i].u.upper == v.u.upper)
						max = Math.max(max, X(V3[i], state+1));
				}
			} else {// if (state == 4)
				for (int i = 0; i < V3.length; i++) {
					if ( V3[i].u.equals(v.u)
							&& V3[i].u.upper == v.u.upper)
						max = Math.max(max, X(V3[i],state+1));
				}
			}
			return max;
		} else if (state == 6) {
			double max = 0;
			for (int i = 1; i < 16; i++) {
				if (v.u.playableCategories[i]) {
					Tuple u = null;
					int upper = v.u.upper;
					int iter = 0;
					boolean[] newPlayable = new boolean[16];
					newPlayable = v.u.playableCategories.clone();
					newPlayable[i] = false;
					while (iter < V1.length) {
						// Find the Iteration value of the element corresponding
						// to correct values, there is only one.
						if (i < 7) {
							upper += SPrime(v, u);
							if (upper > 63)
								upper = 63;
							u = new Tuple(newPlayable, upper);
						} else
							u = new Tuple(newPlayable, upper);
						if (V1[iter].equals(u)) {
							break;
						}
						iter++;
					}
					double tmp = S(v, V1[iter]) + X(V1[iter]);
					if (tmp > max) {
						max = tmp;
					}
				}
			}
			return max;
		}
		System.out.println("Reached unreachable point in X(Element v)");
		System.err.println(" Shit just got bad in method X(Element v) ");
		return -1;
	}

	/**
	 * Check if uDices == vDices or if uDices is a subset of vDices.
	 * 
	 * @param vDices
	 *            set of 5 ints.
	 * @param uDices
	 *            set of 0-5 ints.
	 * @return true if uDices is a subset to vDices, otherwise false.
	 */
	public static boolean contains(short[] vDices, short[] uDices) {
		Arrays.sort(vDices);
		Arrays.sort(uDices);
		if (uDices.length == 5) {
			return vDices.equals(uDices);
		}
		for (int i = 0; i < (6 - uDices.length); i++) {
			boolean equal = true;
			for (int j = i; j < (i + uDices.length); j++)
				if (uDices[j - i] != vDices[j]) {
					equal = false;
					break;
				} else if (j == (uDices.length - 1 + i) && equal)
					return true;
		}
		return false;
	}

	/**
	 * Calculating the probability of getting from v -> u.
	 * 
	 * @param v
	 *            Current element
	 * @param u
	 *            Reachable element
	 * @return probability of reaching u from v.
	 */
	public static double probability(Element v, Element u) {
		return NewOptimalAlgorithm.probability(v.dices, u.dices, 1);
	}

	/**
	 * Static method for playing yahtzee
	 */
	public static int play() {
		ScoreCard sc = new ScoreCard();
		OptimalStatebasedAlgorithm osa = new OptimalStatebasedAlgorithm();

		// TODO run algorithm for playing.
		return sc.getTotalScore();
	}

	/**
	 * Used to play several games of yahtzee without recalculating the graph.
	 * 
	 * @param runs
	 *            Number of thimes to run the test.
	 * @return
	 */
	public static int playMultiple(int runs) {
		ScoreCard sc = new ScoreCard();
		OptimalStatebasedAlgorithm osa = new OptimalStatebasedAlgorithm();
		for (int i = 0; i < runs; i++) {
			// TODO run algorithm for playing.
		}
		return sc.getTotalScore();
	}
}
